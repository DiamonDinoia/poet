# POET

[![CI Status](https://img.shields.io/badge/CI-GitHub%20Actions-lightgrey)](https://github.com/DiamonDinoia/poet/actions)
[![License: MIT](https://img.shields.io/badge/License-MIT-blue.svg)](LICENSE)
[![C++ Standard](https://img.shields.io/badge/C%2B%2B-17%2B-lightblue)](https://en.cppreference.com/w/cpp/17)
[![Coverage](https://codecov.io/gh/DiamonDinoia/poet/branch/main/graph/badge.svg)](https://codecov.io/gh/DiamonDinoia/poet)
[![Docs Status](https://readthedocs.org/projects/poet/badge/?version=latest)](https://poet.readthedocs.io/en/latest/)

POET is a small, header-only C++ utility library that provides compile-time oriented loop and dispatch
primitives to make high-performance metaprogramming simpler and safer. It focuses on three complementary
capabilities:

- static_for — compile-time unrolled loops for iterating integer ranges or template packs.
- dynamic_for — efficient runtime loops implemented by emitting compile-time unrolled blocks.
- dispatch / DispatchSet — map runtime integers or tuples to compile-time non-type template parameters
  for zero-cost specialization.
- register_info — compile-time CPU register and SIMD capability detection for tuning
  unroll factors and block sizes to the target ISA.

## Why it matters

These utilities let you express algorithms that benefit from compile-time specialization (inlining,
unrolling, and better optimization) while still driving them from runtime values. The result is code
that is both efficient (no virtual calls, fewer branches) and expressive, useful in hotspots such as
small-linear algebra, kernel selection, and template-based code generation.

In particular, POET's runtime-to-compile-time dispatch lets you select optimized, specialized code
paths based on runtime choices with zero-cost abstraction.

## Performance benefits

Making iteration counts and dispatch targets visible at compile time often improves register utilization
and codegen quality: the compiler can allocate registers across unrolled iterations and specialized paths,
reduce spills, enable better instruction scheduling, and expose opportunities for vectorization.

Common hotspots that benefit:

- Small, fixed-size dense linear algebra (small GEMM, batched matrix ops)
- Tight convolution / stencil kernels and small-kernel DSP code
- Fixed-size FFT/DFT implementations
- Hot parsing/serialization loops and state machines with fixed-state graphs
- Kernel-selection/specialization in template-based libraries where runtime choices select optimized
  codepaths

### Benchmark results

Charts generated by CI across GCC and Clang ([workflow](https://github.com/DiamonDinoia/poet/actions/workflows/benchmarks.yml)):

**dynamic_for** — Multi-accumulator ILP: compile-time lane indices let the compiler
maintain independent accumulator chains, breaking serial dependency bottlenecks.

![dynamic_for speedup](https://raw.githubusercontent.com/DiamonDinoia/poet/benchmark-results/benchmark-results/dynamic_for_speedup.svg)

**static_for** — Register-aware block sizing: tuning the unroll factor to match
available SIMD registers avoids spill-induced slowdowns while maximizing throughput.

![static_for speedup](https://raw.githubusercontent.com/DiamonDinoia/poet/benchmark-results/benchmark-results/static_for_speedup.svg)

**dispatch** — Compile-time specialization: when N is known at compile time, the
compiler fully unrolls evaluation loops, constant-folds coefficients, and schedules
instructions optimally — often 2-5x faster than runtime N.

![dispatch optimization](https://raw.githubusercontent.com/DiamonDinoia/poet/benchmark-results/benchmark-results/dispatch_optimization.svg)

**Cross-compiler consistency** — POET's optimizations deliver consistent speedups
across both GCC and Clang, showing that the patterns are robust and not
compiler-specific.

![cross-compiler overview](https://raw.githubusercontent.com/DiamonDinoia/poet/benchmark-results/benchmark-results/cross_compiler_overview.svg)

## Basic usage examples

Include the umbrella header:

```cpp
#include <poet/poet.hpp>
```

### static_for — compile-time unrolling

```cpp
#include <iostream>

int main() {
  poet::static_for<0, 5>([](auto I) {
    // I is std::integral_constant<std::ptrdiff_t, N>
    std::cout << decltype(I)::value << '\n';
  });
}
```

### dynamic_for — runtime loop with compile-time blocks

```cpp
#include <iostream>

int main() {
  std::size_t n = 37;
  poet::dynamic_for<8>(0u, n, [](std::size_t i) {
    // body executed for i = 0..n-1 in unrolled blocks of 8
    std::cout << i << '\n';
  });
}
```

`dynamic_for` callable forms:

- `func(index)`
- `func(lane, index)` where `lane` is `std::integral_constant<std::size_t, L>`

When the stride is a compile-time constant, use the template-parameter overload
`poet::dynamic_for<Unroll, Step>(begin, end, func)` to enable constant-folded per-lane arithmetic
and lighter tail dispatch. See the [dynamic_for guide](docs/guides/dynamic_for.rst) for details.

### Note on C++20 ranges and the piping adaptor

The header `<poet/core/dynamic_for.hpp>` supports C++20 pipe ranges or tuple-like (begin,end,step)
values into a dynamic_for. Example:

```cpp
#include <ranges>
auto r = std::views::iota(0) | std::views::take(10);
r | poet::make_dynamic_for<4>([](int i){ /* i = 0..9 (eager) */ });

std::tuple{0, 24, 2} | poet::make_dynamic_for<4>([](int i){ /* i = 0,2,4,...,22 */ });
```

Notes:

- The adaptor is an eager sink: it computes the length of the input (single-pass for non-sized
  ranges) and calls `poet::dynamic_for` immediately.

### dispatch — map runtime values to compile-time templates

```cpp
#include <iostream>

struct Impl {
  template<int N>
  void operator()(int x) const {
    std::cout << "specialized N=" << N << " x=" << x << '\n';
  }
};

int main() {
  int runtime_choice = 2;

  // Tuple form: wrap DispatchParams in a std::tuple
  auto params = std::make_tuple(poet::DispatchParam<poet::make_range<0, 4>>{ runtime_choice });
  poet::dispatch(Impl{}, params, 42); // calls Impl::operator()<2>(42) if in range

  // Variadic form: pass DispatchParams directly followed by runtime args
  poet::dispatch(Impl{}, poet::DispatchParam<poet::make_range<0, 4>>{ runtime_choice }, 42);
}
```

### dispatch with DispatchSet — sparse tuple dispatch

```cpp
struct Impl2 {
  template<int A, int B>
  void operator()(const std::string &s) const {
    std::cout << A << "," << B << " -> " << s << '\n';
  }
};

int main() {
  poet::DispatchSet<int, poet::T<1,2>, poet::T<3,4>> set(1, 2);
  poet::dispatch(Impl2{}, set, std::string("hello")); // calls Impl2::operator()<1,2>
}
```

### Throwing dispatch

Some overloads of `dispatch` accept the tag `poet::throw_t` (alias of `throw_on_no_match_t`) as the
first argument and will throw `poet::no_match_error` (inherits from `std::runtime_error`) when no
compile-time match exists. This is useful when a missing specialization is a fatal configuration error.

```cpp
#include <iostream>
#include <stdexcept>

struct Impl3 {
  template<int N>
  int operator()(int x) const { return N + x; }
};

int main() {
  try {
    int runtime_choice = 10;
    auto params = std::make_tuple(poet::DispatchParam<poet::make_range<0,4>>{ runtime_choice });
    // Throws poet::no_match_error because 10 is not in [0..4]
    int result = poet::dispatch(poet::throw_t, Impl3{}, params, 5);
    std::cout << result << '\n';
  } catch (const poet::no_match_error &e) {
    std::cerr << "dispatch failed: " << e.what() << '\n';
  }
}
```

## Install / Integrate

(Installation instructions moved below the basic examples for readers who first want to see usage.)

1. Clone

   ```bash
   git clone https://github.com/DiamonDinoia/poet.git
   ```

1. CMake — add_subdirectory (recommended for local development)

   ```cmake
   add_subdirectory(path/to/poet)
   add_executable(my_app main.cpp)
   target_link_libraries(my_app PRIVATE poet::poet)
   ```

1. CMake — find_package (after install)

   ```cmake
   # After you install POET somewhere with `cmake --install`,
   # discover it via CMake's package config:
   find_package(poet CONFIG REQUIRED)

   add_executable(my_app main.cpp)
   target_link_libraries(my_app PRIVATE poet::poet)
   ```

1. CMake — FetchContent

   ```cmake
   include(FetchContent)
   FetchContent_Declare(poet GIT_REPOSITORY https://github.com/DiamonDinoia/poet.git GIT_TAG main)
   FetchContent_MakeAvailable(poet)
   target_link_libraries(my_app PRIVATE poet::poet)
   ```

1. CMake — CPM.cmake

   ```cmake
   # Requires CPM.cmake available in your project
   # See https://github.com/cpm-cmake/CPM.cmake for setup

   CPMAddPackage(
     NAME poet
     GITHUB_REPOSITORY DiamonDinoia/poet
     GIT_TAG main
   )

   add_executable(my_app main.cpp)
   target_link_libraries(my_app PRIVATE poet::poet)
   ```

1. Header-only usage (no build step)

   - Add the repository `include/` directory to your compiler include path and compile your code:

     ```bash
     g++ -std=c++17 -I/path/to/poet/include your.cpp -o your_app
     ```

## Documentation and License

- Full API docs and guides: <https://poet.readthedocs.io/en/latest/> (includes Doxygen-generated
  API reference)
- License: MIT (see LICENSE file)

## Contributing

PRs and issues welcome.
